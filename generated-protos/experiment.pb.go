// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.30.0
// 	protoc        v3.19.4
// source: data-formats/experiment.proto

package protos

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Experiment_MetaDataType int32

const (
	Experiment_MT_FLOAT  Experiment_MetaDataType = 0
	Experiment_MT_INT    Experiment_MetaDataType = 1
	Experiment_MT_STRING Experiment_MetaDataType = 2
)

// Enum value maps for Experiment_MetaDataType.
var (
	Experiment_MetaDataType_name = map[int32]string{
		0: "MT_FLOAT",
		1: "MT_INT",
		2: "MT_STRING",
	}
	Experiment_MetaDataType_value = map[string]int32{
		"MT_FLOAT":  0,
		"MT_INT":    1,
		"MT_STRING": 2,
	}
)

func (x Experiment_MetaDataType) Enum() *Experiment_MetaDataType {
	p := new(Experiment_MetaDataType)
	*p = x
	return p
}

func (x Experiment_MetaDataType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Experiment_MetaDataType) Descriptor() protoreflect.EnumDescriptor {
	return file_data_formats_experiment_proto_enumTypes[0].Descriptor()
}

func (Experiment_MetaDataType) Type() protoreflect.EnumType {
	return &file_data_formats_experiment_proto_enumTypes[0]
}

func (x Experiment_MetaDataType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Experiment_MetaDataType.Descriptor instead.
func (Experiment_MetaDataType) EnumDescriptor() ([]byte, []int) {
	return file_data_formats_experiment_proto_rawDescGZIP(), []int{0, 0}
}

type Experiment_Location_SpectrumCompression int32

const (
	Experiment_Location_RAW      Experiment_Location_SpectrumCompression = 0 // Storing raw data, so N*int32 in size
	Experiment_Location_ZERO_RUN Experiment_Location_SpectrumCompression = 1 // 0's all have a count after them. Assumption is a lot of runs of 0's
	Experiment_Location_RLE      Experiment_Location_SpectrumCompression = 2 // Run length encoding, assumption is many numbers have long runs
)

// Enum value maps for Experiment_Location_SpectrumCompression.
var (
	Experiment_Location_SpectrumCompression_name = map[int32]string{
		0: "RAW",
		1: "ZERO_RUN",
		2: "RLE",
	}
	Experiment_Location_SpectrumCompression_value = map[string]int32{
		"RAW":      0,
		"ZERO_RUN": 1,
		"RLE":      2,
	}
)

func (x Experiment_Location_SpectrumCompression) Enum() *Experiment_Location_SpectrumCompression {
	p := new(Experiment_Location_SpectrumCompression)
	*p = x
	return p
}

func (x Experiment_Location_SpectrumCompression) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Experiment_Location_SpectrumCompression) Descriptor() protoreflect.EnumDescriptor {
	return file_data_formats_experiment_proto_enumTypes[1].Descriptor()
}

func (Experiment_Location_SpectrumCompression) Type() protoreflect.EnumType {
	return &file_data_formats_experiment_proto_enumTypes[1]
}

func (x Experiment_Location_SpectrumCompression) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Experiment_Location_SpectrumCompression.Descriptor instead.
func (Experiment_Location_SpectrumCompression) EnumDescriptor() ([]byte, []int) {
	return file_data_formats_experiment_proto_rawDescGZIP(), []int{0, 3, 0}
}

type Experiment struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Dataset Summary meta fields are stored as JSON outside of here, a lot of those values being derived from
	//
	//	counts of items in this file. The rest are fields on the root of Experiment here. This way anything that
	//	has access to an Experiment file won't need to also download the corresponding Dataset Summary.
	//	NOTE: Now that we support combining scans, these fields may not be set if it's a combination dataset
	TargetId string `protobuf:"bytes,1,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"`
	DriveId  int32  `protobuf:"varint,11,opt,name=drive_id,json=driveId,proto3" json:"drive_id,omitempty"`
	SiteId   int32  `protobuf:"varint,12,opt,name=site_id,json=siteId,proto3" json:"site_id,omitempty"`
	Target   string `protobuf:"bytes,13,opt,name=target,proto3" json:"target,omitempty"`
	Site     string `protobuf:"bytes,14,opt,name=site,proto3" json:"site,omitempty"`
	Title    string `protobuf:"bytes,15,opt,name=title,proto3" json:"title,omitempty"`
	Sol      string `protobuf:"bytes,25,opt,name=sol,proto3" json:"sol,omitempty"`
	Rtt      int32  `protobuf:"varint,17,opt,name=rtt,proto3" json:"rtt,omitempty"`
	Sclk     int32  `protobuf:"varint,18,opt,name=sclk,proto3" json:"sclk,omitempty"`
	// If we were generated when a bulk sum quant file existed, the file name is stored here for loading
	BulkSumQuantFile string `protobuf:"bytes,9,opt,name=bulk_sum_quant_file,json=bulkSumQuantFile,proto3" json:"bulk_sum_quant_file,omitempty"`
	// What is the detector configuration that this file was generated for
	DetectorConfig string `protobuf:"bytes,10,opt,name=detector_config,json=detectorConfig,proto3" json:"detector_config,omitempty"`
	// Counts, these can be counted by iterating through Locations but we store them here for reference
	//
	//	NOTE: These will always be set!
	BulkSpectra       int32 `protobuf:"varint,19,opt,name=bulk_spectra,json=bulkSpectra,proto3" json:"bulk_spectra,omitempty"`
	DwellSpectra      int32 `protobuf:"varint,20,opt,name=dwell_spectra,json=dwellSpectra,proto3" json:"dwell_spectra,omitempty"`
	MaxSpectra        int32 `protobuf:"varint,21,opt,name=max_spectra,json=maxSpectra,proto3" json:"max_spectra,omitempty"`
	NormalSpectra     int32 `protobuf:"varint,22,opt,name=normal_spectra,json=normalSpectra,proto3" json:"normal_spectra,omitempty"`
	PseudoIntensities int32 `protobuf:"varint,23,opt,name=pseudo_intensities,json=pseudoIntensities,proto3" json:"pseudo_intensities,omitempty"`
	// This is the main or default context image to show. It matches either one of the images in aligned_context_images
	//
	//	or one in unaligned_context_images
	MainContextImage     string                                   `protobuf:"bytes,2,opt,name=main_context_image,json=mainContextImage,proto3" json:"main_context_image,omitempty"`
	ScanSources          []*Experiment_ScanSource                 `protobuf:"bytes,27,rep,name=scan_sources,json=scanSources,proto3" json:"scan_sources,omitempty"`
	AlignedContextImages []*Experiment_ContextImageCoordinateInfo `protobuf:"bytes,24,rep,name=aligned_context_images,json=alignedContextImages,proto3" json:"aligned_context_images,omitempty"`
	// Any other images, which we don't have beam location information for are in this array
	UnalignedContextImages      []string                              `protobuf:"bytes,6,rep,name=unaligned_context_images,json=unalignedContextImages,proto3" json:"unaligned_context_images,omitempty"`
	MatchedAlignedContextImages []*Experiment_MatchedContextImageInfo `protobuf:"bytes,26,rep,name=matched_aligned_context_images,json=matchedAlignedContextImages,proto3" json:"matched_aligned_context_images,omitempty"`
	// The labels and types of metadata fields we've stored in locations. This way MetaDataItem can refer to
	//
	//	these arrays and not need to store redundant copies of the field name strings
	MetaLabels            []string                           `protobuf:"bytes,3,rep,name=meta_labels,json=metaLabels,proto3" json:"meta_labels,omitempty"`
	MetaTypes             []Experiment_MetaDataType          `protobuf:"varint,4,rep,packed,name=meta_types,json=metaTypes,proto3,enum=Experiment_MetaDataType" json:"meta_types,omitempty"`
	Locations             []*Experiment_Location             `protobuf:"bytes,5,rep,name=locations,proto3" json:"locations,omitempty"`
	PseudoIntensityRanges []*Experiment_PseudoIntensityRange `protobuf:"bytes,8,rep,name=pseudo_intensity_ranges,json=pseudoIntensityRanges,proto3" json:"pseudo_intensity_ranges,omitempty"`
}

func (x *Experiment) Reset() {
	*x = Experiment{}
	if protoimpl.UnsafeEnabled {
		mi := &file_data_formats_experiment_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Experiment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Experiment) ProtoMessage() {}

func (x *Experiment) ProtoReflect() protoreflect.Message {
	mi := &file_data_formats_experiment_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Experiment.ProtoReflect.Descriptor instead.
func (*Experiment) Descriptor() ([]byte, []int) {
	return file_data_formats_experiment_proto_rawDescGZIP(), []int{0}
}

func (x *Experiment) GetTargetId() string {
	if x != nil {
		return x.TargetId
	}
	return ""
}

func (x *Experiment) GetDriveId() int32 {
	if x != nil {
		return x.DriveId
	}
	return 0
}

func (x *Experiment) GetSiteId() int32 {
	if x != nil {
		return x.SiteId
	}
	return 0
}

func (x *Experiment) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

func (x *Experiment) GetSite() string {
	if x != nil {
		return x.Site
	}
	return ""
}

func (x *Experiment) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *Experiment) GetSol() string {
	if x != nil {
		return x.Sol
	}
	return ""
}

func (x *Experiment) GetRtt() int32 {
	if x != nil {
		return x.Rtt
	}
	return 0
}

func (x *Experiment) GetSclk() int32 {
	if x != nil {
		return x.Sclk
	}
	return 0
}

func (x *Experiment) GetBulkSumQuantFile() string {
	if x != nil {
		return x.BulkSumQuantFile
	}
	return ""
}

func (x *Experiment) GetDetectorConfig() string {
	if x != nil {
		return x.DetectorConfig
	}
	return ""
}

func (x *Experiment) GetBulkSpectra() int32 {
	if x != nil {
		return x.BulkSpectra
	}
	return 0
}

func (x *Experiment) GetDwellSpectra() int32 {
	if x != nil {
		return x.DwellSpectra
	}
	return 0
}

func (x *Experiment) GetMaxSpectra() int32 {
	if x != nil {
		return x.MaxSpectra
	}
	return 0
}

func (x *Experiment) GetNormalSpectra() int32 {
	if x != nil {
		return x.NormalSpectra
	}
	return 0
}

func (x *Experiment) GetPseudoIntensities() int32 {
	if x != nil {
		return x.PseudoIntensities
	}
	return 0
}

func (x *Experiment) GetMainContextImage() string {
	if x != nil {
		return x.MainContextImage
	}
	return ""
}

func (x *Experiment) GetScanSources() []*Experiment_ScanSource {
	if x != nil {
		return x.ScanSources
	}
	return nil
}

func (x *Experiment) GetAlignedContextImages() []*Experiment_ContextImageCoordinateInfo {
	if x != nil {
		return x.AlignedContextImages
	}
	return nil
}

func (x *Experiment) GetUnalignedContextImages() []string {
	if x != nil {
		return x.UnalignedContextImages
	}
	return nil
}

func (x *Experiment) GetMatchedAlignedContextImages() []*Experiment_MatchedContextImageInfo {
	if x != nil {
		return x.MatchedAlignedContextImages
	}
	return nil
}

func (x *Experiment) GetMetaLabels() []string {
	if x != nil {
		return x.MetaLabels
	}
	return nil
}

func (x *Experiment) GetMetaTypes() []Experiment_MetaDataType {
	if x != nil {
		return x.MetaTypes
	}
	return nil
}

func (x *Experiment) GetLocations() []*Experiment_Location {
	if x != nil {
		return x.Locations
	}
	return nil
}

func (x *Experiment) GetPseudoIntensityRanges() []*Experiment_PseudoIntensityRange {
	if x != nil {
		return x.PseudoIntensityRanges
	}
	return nil
}

// A long time after we had individual datasets as above, we decided to support combination of multiple scans
//
//	into one dataset. This required the ability to store meta data from each. In the Locations array, each location
//	has an index to define which scan source it is from. The absense of scan_sources indicates this is an individual
//	scan, not a combined one
type Experiment_ScanSource struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Instrument string `protobuf:"bytes,1,opt,name=instrument,proto3" json:"instrument,omitempty"`
	// Dataset Summary meta fields are stored as JSON outside of here, a lot of those values being derived from
	//
	//	counts of items in this file. The rest are fields on the root of Experiment here. This way anything that
	//	has access to an Experiment file won't need to also download the corresponding Dataset Summary.
	TargetId         string `protobuf:"bytes,2,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"`
	DriveId          int32  `protobuf:"varint,3,opt,name=drive_id,json=driveId,proto3" json:"drive_id,omitempty"`
	SiteId           int32  `protobuf:"varint,4,opt,name=site_id,json=siteId,proto3" json:"site_id,omitempty"`
	Target           string `protobuf:"bytes,5,opt,name=target,proto3" json:"target,omitempty"`
	Site             string `protobuf:"bytes,6,opt,name=site,proto3" json:"site,omitempty"`
	Title            string `protobuf:"bytes,7,opt,name=title,proto3" json:"title,omitempty"`
	Sol              string `protobuf:"bytes,8,opt,name=sol,proto3" json:"sol,omitempty"`
	Rtt              string `protobuf:"bytes,9,opt,name=rtt,proto3" json:"rtt,omitempty"`
	Sclk             int32  `protobuf:"varint,10,opt,name=sclk,proto3" json:"sclk,omitempty"`
	BulkSumQuantFile string `protobuf:"bytes,11,opt,name=bulk_sum_quant_file,json=bulkSumQuantFile,proto3" json:"bulk_sum_quant_file,omitempty"`
	DetectorConfig   string `protobuf:"bytes,12,opt,name=detector_config,json=detectorConfig,proto3" json:"detector_config,omitempty"`
	IdOffset         int32  `protobuf:"varint,13,opt,name=id_offset,json=idOffset,proto3" json:"id_offset,omitempty"`
}

func (x *Experiment_ScanSource) Reset() {
	*x = Experiment_ScanSource{}
	if protoimpl.UnsafeEnabled {
		mi := &file_data_formats_experiment_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Experiment_ScanSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Experiment_ScanSource) ProtoMessage() {}

func (x *Experiment_ScanSource) ProtoReflect() protoreflect.Message {
	mi := &file_data_formats_experiment_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Experiment_ScanSource.ProtoReflect.Descriptor instead.
func (*Experiment_ScanSource) Descriptor() ([]byte, []int) {
	return file_data_formats_experiment_proto_rawDescGZIP(), []int{0, 0}
}

func (x *Experiment_ScanSource) GetInstrument() string {
	if x != nil {
		return x.Instrument
	}
	return ""
}

func (x *Experiment_ScanSource) GetTargetId() string {
	if x != nil {
		return x.TargetId
	}
	return ""
}

func (x *Experiment_ScanSource) GetDriveId() int32 {
	if x != nil {
		return x.DriveId
	}
	return 0
}

func (x *Experiment_ScanSource) GetSiteId() int32 {
	if x != nil {
		return x.SiteId
	}
	return 0
}

func (x *Experiment_ScanSource) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

func (x *Experiment_ScanSource) GetSite() string {
	if x != nil {
		return x.Site
	}
	return ""
}

func (x *Experiment_ScanSource) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *Experiment_ScanSource) GetSol() string {
	if x != nil {
		return x.Sol
	}
	return ""
}

func (x *Experiment_ScanSource) GetRtt() string {
	if x != nil {
		return x.Rtt
	}
	return ""
}

func (x *Experiment_ScanSource) GetSclk() int32 {
	if x != nil {
		return x.Sclk
	}
	return 0
}

func (x *Experiment_ScanSource) GetBulkSumQuantFile() string {
	if x != nil {
		return x.BulkSumQuantFile
	}
	return ""
}

func (x *Experiment_ScanSource) GetDetectorConfig() string {
	if x != nil {
		return x.DetectorConfig
	}
	return ""
}

func (x *Experiment_ScanSource) GetIdOffset() int32 {
	if x != nil {
		return x.IdOffset
	}
	return 0
}

// Aligned context image - describes which PMC images are defined for, and if they're trapezoid corrected. This is
//
//	stored in the same order as location BeamLocation i/j coordinates, so [0] is BeamLocation.image_i/image_j and
//	[1] is BeamLocation.context_locations[0], etc
//	Can think of this as the metadata to describe what's in a beam location object
type Experiment_ContextImageCoordinateInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Image              string `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`                                                      // image file name
	Pmc                int32  `protobuf:"varint,2,opt,name=pmc,proto3" json:"pmc,omitempty"`                                                         // PMC for the image
	TrapezoidCorrected bool   `protobuf:"varint,3,opt,name=trapezoid_corrected,json=trapezoidCorrected,proto3" json:"trapezoid_corrected,omitempty"` // Is this image trapezoid corrected
	ScanSource         int32  `protobuf:"varint,4,opt,name=scan_source,json=scanSource,proto3" json:"scan_source,omitempty"`                         // Not set if this is not a combined dataset
}

func (x *Experiment_ContextImageCoordinateInfo) Reset() {
	*x = Experiment_ContextImageCoordinateInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_data_formats_experiment_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Experiment_ContextImageCoordinateInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Experiment_ContextImageCoordinateInfo) ProtoMessage() {}

func (x *Experiment_ContextImageCoordinateInfo) ProtoReflect() protoreflect.Message {
	mi := &file_data_formats_experiment_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Experiment_ContextImageCoordinateInfo.ProtoReflect.Descriptor instead.
func (*Experiment_ContextImageCoordinateInfo) Descriptor() ([]byte, []int) {
	return file_data_formats_experiment_proto_rawDescGZIP(), []int{0, 1}
}

func (x *Experiment_ContextImageCoordinateInfo) GetImage() string {
	if x != nil {
		return x.Image
	}
	return ""
}

func (x *Experiment_ContextImageCoordinateInfo) GetPmc() int32 {
	if x != nil {
		return x.Pmc
	}
	return 0
}

func (x *Experiment_ContextImageCoordinateInfo) GetTrapezoidCorrected() bool {
	if x != nil {
		return x.TrapezoidCorrected
	}
	return false
}

func (x *Experiment_ContextImageCoordinateInfo) GetScanSource() int32 {
	if x != nil {
		return x.ScanSource
	}
	return 0
}

// Matched context image - list of context images which have been transformed to match a given PMC's MCC
//
//	image (in aligned_context_images), for example WATSON images. The image needs to be transformed so the MCC image
//	area matches pixel-for-pixel, but the image is likely to be of a different size, so we include an x/y offset.
//	This gives the top-left pixel coordinate of MCC image relative to the top-left of the matched image. This way
//	the PMC beam locations can be reused to draw their position on the matched image.
type Experiment_MatchedContextImageInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Image        string  `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`                                    // image file name
	AlignedIndex int32   `protobuf:"varint,2,opt,name=aligned_index,json=alignedIndex,proto3" json:"aligned_index,omitempty"` // aligned_context_images array index this one matches
	XOffset      float32 `protobuf:"fixed32,3,opt,name=x_offset,json=xOffset,proto3" json:"x_offset,omitempty"`               // x-offset of matched left edge vs aligned image
	YOffset      float32 `protobuf:"fixed32,4,opt,name=y_offset,json=yOffset,proto3" json:"y_offset,omitempty"`               // y-offset of matched top edge vs aligned image
	XScale       float32 `protobuf:"fixed32,5,opt,name=x_scale,json=xScale,proto3" json:"x_scale,omitempty"`                  // x-scale of matched vs aligned width, if matched is 2000 wide, aligned is 1000, this=2
	YScale       float32 `protobuf:"fixed32,6,opt,name=y_scale,json=yScale,proto3" json:"y_scale,omitempty"`                  // y-scale of matched vs aligned height
}

func (x *Experiment_MatchedContextImageInfo) Reset() {
	*x = Experiment_MatchedContextImageInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_data_formats_experiment_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Experiment_MatchedContextImageInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Experiment_MatchedContextImageInfo) ProtoMessage() {}

func (x *Experiment_MatchedContextImageInfo) ProtoReflect() protoreflect.Message {
	mi := &file_data_formats_experiment_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Experiment_MatchedContextImageInfo.ProtoReflect.Descriptor instead.
func (*Experiment_MatchedContextImageInfo) Descriptor() ([]byte, []int) {
	return file_data_formats_experiment_proto_rawDescGZIP(), []int{0, 2}
}

func (x *Experiment_MatchedContextImageInfo) GetImage() string {
	if x != nil {
		return x.Image
	}
	return ""
}

func (x *Experiment_MatchedContextImageInfo) GetAlignedIndex() int32 {
	if x != nil {
		return x.AlignedIndex
	}
	return 0
}

func (x *Experiment_MatchedContextImageInfo) GetXOffset() float32 {
	if x != nil {
		return x.XOffset
	}
	return 0
}

func (x *Experiment_MatchedContextImageInfo) GetYOffset() float32 {
	if x != nil {
		return x.YOffset
	}
	return 0
}

func (x *Experiment_MatchedContextImageInfo) GetXScale() float32 {
	if x != nil {
		return x.XScale
	}
	return 0
}

func (x *Experiment_MatchedContextImageInfo) GetYScale() float32 {
	if x != nil {
		return x.YScale
	}
	return 0
}

type Experiment_Location struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id                  string                                  `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ScanSource          int32                                   `protobuf:"varint,9,opt,name=scan_source,json=scanSource,proto3" json:"scan_source,omitempty"` // Not set if this is not a combined dataset
	Meta                []*Experiment_Location_MetaDataItem     `protobuf:"bytes,2,rep,name=meta,proto3" json:"meta,omitempty"`
	Beam                *Experiment_Location_BeamLocation       `protobuf:"bytes,3,opt,name=beam,proto3" json:"beam,omitempty"`
	SpectrumCompression Experiment_Location_SpectrumCompression `protobuf:"varint,4,opt,name=spectrum_compression,json=spectrumCompression,proto3,enum=Experiment_Location_SpectrumCompression" json:"spectrum_compression,omitempty"`
	// Need multiple of these, detector A & B but can have normal & dwell
	Detectors []*Experiment_Location_DetectorSpectrum `protobuf:"bytes,5,rep,name=detectors,proto3" json:"detectors,omitempty"`
	// Ability to store an image per PMC, FM data several images with different PMCs in the file name
	ContextImage      string                                     `protobuf:"bytes,6,opt,name=context_image,json=contextImage,proto3" json:"context_image,omitempty"`
	PseudoIntensities []*Experiment_Location_PseudoIntensityData `protobuf:"bytes,7,rep,name=pseudo_intensities,json=pseudoIntensities,proto3" json:"pseudo_intensities,omitempty"`
}

func (x *Experiment_Location) Reset() {
	*x = Experiment_Location{}
	if protoimpl.UnsafeEnabled {
		mi := &file_data_formats_experiment_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Experiment_Location) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Experiment_Location) ProtoMessage() {}

func (x *Experiment_Location) ProtoReflect() protoreflect.Message {
	mi := &file_data_formats_experiment_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Experiment_Location.ProtoReflect.Descriptor instead.
func (*Experiment_Location) Descriptor() ([]byte, []int) {
	return file_data_formats_experiment_proto_rawDescGZIP(), []int{0, 3}
}

func (x *Experiment_Location) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Experiment_Location) GetScanSource() int32 {
	if x != nil {
		return x.ScanSource
	}
	return 0
}

func (x *Experiment_Location) GetMeta() []*Experiment_Location_MetaDataItem {
	if x != nil {
		return x.Meta
	}
	return nil
}

func (x *Experiment_Location) GetBeam() *Experiment_Location_BeamLocation {
	if x != nil {
		return x.Beam
	}
	return nil
}

func (x *Experiment_Location) GetSpectrumCompression() Experiment_Location_SpectrumCompression {
	if x != nil {
		return x.SpectrumCompression
	}
	return Experiment_Location_RAW
}

func (x *Experiment_Location) GetDetectors() []*Experiment_Location_DetectorSpectrum {
	if x != nil {
		return x.Detectors
	}
	return nil
}

func (x *Experiment_Location) GetContextImage() string {
	if x != nil {
		return x.ContextImage
	}
	return ""
}

func (x *Experiment_Location) GetPseudoIntensities() []*Experiment_Location_PseudoIntensityData {
	if x != nil {
		return x.PseudoIntensities
	}
	return nil
}

// If we have pseudo-intensity data, this will contain the labels of the elements from the CSV, along with
//
//	their channel start/end
type Experiment_PseudoIntensityRange struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Name         string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ChannelStart int32  `protobuf:"varint,2,opt,name=channel_start,json=channelStart,proto3" json:"channel_start,omitempty"`
	ChannelEnd   int32  `protobuf:"varint,3,opt,name=channel_end,json=channelEnd,proto3" json:"channel_end,omitempty"`
}

func (x *Experiment_PseudoIntensityRange) Reset() {
	*x = Experiment_PseudoIntensityRange{}
	if protoimpl.UnsafeEnabled {
		mi := &file_data_formats_experiment_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Experiment_PseudoIntensityRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Experiment_PseudoIntensityRange) ProtoMessage() {}

func (x *Experiment_PseudoIntensityRange) ProtoReflect() protoreflect.Message {
	mi := &file_data_formats_experiment_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Experiment_PseudoIntensityRange.ProtoReflect.Descriptor instead.
func (*Experiment_PseudoIntensityRange) Descriptor() ([]byte, []int) {
	return file_data_formats_experiment_proto_rawDescGZIP(), []int{0, 4}
}

func (x *Experiment_PseudoIntensityRange) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Experiment_PseudoIntensityRange) GetChannelStart() int32 {
	if x != nil {
		return x.ChannelStart
	}
	return 0
}

func (x *Experiment_PseudoIntensityRange) GetChannelEnd() int32 {
	if x != nil {
		return x.ChannelEnd
	}
	return 0
}

type Experiment_Location_MetaDataItem struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Only storing the metadata label outside of the item, here we just store its index
	LabelIdx int32 `protobuf:"varint,1,opt,name=label_idx,json=labelIdx,proto3" json:"label_idx,omitempty"`
	// NOTE: in javascript protobuf there is no "has" function, so each of these report their default
	//
	//	value which means if it's a 0 or 0.0 or '' we don't actually know what type to treat it as, so we
	//	are putting types in an enum list instead, one for each meta_label at the root object!
	Fvalue float32 `protobuf:"fixed32,2,opt,name=fvalue,proto3" json:"fvalue,omitempty"`
	Ivalue int32   `protobuf:"varint,3,opt,name=ivalue,proto3" json:"ivalue,omitempty"`
	Svalue string  `protobuf:"bytes,4,opt,name=svalue,proto3" json:"svalue,omitempty"`
}

func (x *Experiment_Location_MetaDataItem) Reset() {
	*x = Experiment_Location_MetaDataItem{}
	if protoimpl.UnsafeEnabled {
		mi := &file_data_formats_experiment_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Experiment_Location_MetaDataItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Experiment_Location_MetaDataItem) ProtoMessage() {}

func (x *Experiment_Location_MetaDataItem) ProtoReflect() protoreflect.Message {
	mi := &file_data_formats_experiment_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Experiment_Location_MetaDataItem.ProtoReflect.Descriptor instead.
func (*Experiment_Location_MetaDataItem) Descriptor() ([]byte, []int) {
	return file_data_formats_experiment_proto_rawDescGZIP(), []int{0, 3, 0}
}

func (x *Experiment_Location_MetaDataItem) GetLabelIdx() int32 {
	if x != nil {
		return x.LabelIdx
	}
	return 0
}

func (x *Experiment_Location_MetaDataItem) GetFvalue() float32 {
	if x != nil {
		return x.Fvalue
	}
	return 0
}

func (x *Experiment_Location_MetaDataItem) GetIvalue() int32 {
	if x != nil {
		return x.Ivalue
	}
	return 0
}

func (x *Experiment_Location_MetaDataItem) GetSvalue() string {
	if x != nil {
		return x.Svalue
	}
	return ""
}

type Experiment_Location_BeamLocation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	X        float32 `protobuf:"fixed32,1,opt,name=x,proto3" json:"x,omitempty"`
	Y        float32 `protobuf:"fixed32,2,opt,name=y,proto3" json:"y,omitempty"`
	Z        float32 `protobuf:"fixed32,3,opt,name=z,proto3" json:"z,omitempty"`
	GeomCorr float32 `protobuf:"fixed32,7,opt,name=geom_corr,json=geomCorr,proto3" json:"geom_corr,omitempty"`
	// Relative to the image whose file name is in main_context_image
	ImageI float32 `protobuf:"fixed32,4,opt,name=image_i,json=imageI,proto3" json:"image_i,omitempty"`
	ImageJ float32 `protobuf:"fixed32,5,opt,name=image_j,json=imageJ,proto3" json:"image_j,omitempty"`
	// Each context image is taken at different locations, so needs its own relative set of beam location
	//
	//	coordinates. The image_i/image_j coordinates are relative to main_context_image, while here we store
	//	other coordinates, which are relative to the corresponding array item of aligned_context_images. Ended up
	//	this way because we originally we only had one set of i/j's, relative to one context image, and
	//	extending by adding another array was the smoothest in terms of backwards compatibility.
	ContextLocations []*Experiment_Location_BeamLocation_Coordinate2D `protobuf:"bytes,6,rep,name=context_locations,json=contextLocations,proto3" json:"context_locations,omitempty"`
}

func (x *Experiment_Location_BeamLocation) Reset() {
	*x = Experiment_Location_BeamLocation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_data_formats_experiment_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Experiment_Location_BeamLocation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Experiment_Location_BeamLocation) ProtoMessage() {}

func (x *Experiment_Location_BeamLocation) ProtoReflect() protoreflect.Message {
	mi := &file_data_formats_experiment_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Experiment_Location_BeamLocation.ProtoReflect.Descriptor instead.
func (*Experiment_Location_BeamLocation) Descriptor() ([]byte, []int) {
	return file_data_formats_experiment_proto_rawDescGZIP(), []int{0, 3, 1}
}

func (x *Experiment_Location_BeamLocation) GetX() float32 {
	if x != nil {
		return x.X
	}
	return 0
}

func (x *Experiment_Location_BeamLocation) GetY() float32 {
	if x != nil {
		return x.Y
	}
	return 0
}

func (x *Experiment_Location_BeamLocation) GetZ() float32 {
	if x != nil {
		return x.Z
	}
	return 0
}

func (x *Experiment_Location_BeamLocation) GetGeomCorr() float32 {
	if x != nil {
		return x.GeomCorr
	}
	return 0
}

func (x *Experiment_Location_BeamLocation) GetImageI() float32 {
	if x != nil {
		return x.ImageI
	}
	return 0
}

func (x *Experiment_Location_BeamLocation) GetImageJ() float32 {
	if x != nil {
		return x.ImageJ
	}
	return 0
}

func (x *Experiment_Location_BeamLocation) GetContextLocations() []*Experiment_Location_BeamLocation_Coordinate2D {
	if x != nil {
		return x.ContextLocations
	}
	return nil
}

// Spectrum data, stored as specified in spectrum_compression
type Experiment_Location_DetectorSpectrum struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Meta        []*Experiment_Location_MetaDataItem `protobuf:"bytes,1,rep,name=meta,proto3" json:"meta,omitempty"`
	Spectrum    []int32                             `protobuf:"varint,2,rep,packed,name=spectrum,proto3" json:"spectrum,omitempty"`
	SpectrumMax int32                               `protobuf:"varint,3,opt,name=spectrumMax,proto3" json:"spectrumMax,omitempty"`
}

func (x *Experiment_Location_DetectorSpectrum) Reset() {
	*x = Experiment_Location_DetectorSpectrum{}
	if protoimpl.UnsafeEnabled {
		mi := &file_data_formats_experiment_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Experiment_Location_DetectorSpectrum) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Experiment_Location_DetectorSpectrum) ProtoMessage() {}

func (x *Experiment_Location_DetectorSpectrum) ProtoReflect() protoreflect.Message {
	mi := &file_data_formats_experiment_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Experiment_Location_DetectorSpectrum.ProtoReflect.Descriptor instead.
func (*Experiment_Location_DetectorSpectrum) Descriptor() ([]byte, []int) {
	return file_data_formats_experiment_proto_rawDescGZIP(), []int{0, 3, 2}
}

func (x *Experiment_Location_DetectorSpectrum) GetMeta() []*Experiment_Location_MetaDataItem {
	if x != nil {
		return x.Meta
	}
	return nil
}

func (x *Experiment_Location_DetectorSpectrum) GetSpectrum() []int32 {
	if x != nil {
		return x.Spectrum
	}
	return nil
}

func (x *Experiment_Location_DetectorSpectrum) GetSpectrumMax() int32 {
	if x != nil {
		return x.SpectrumMax
	}
	return 0
}

// Storage of pseudo-intensities. NOTE: we currently assume there'll be a detector_id, we may only store
//
//	one set, with detector_id missing, this data structure works in both scenarios
type Experiment_Location_PseudoIntensityData struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	DetectorId string `protobuf:"bytes,1,opt,name=detector_id,json=detectorId,proto3" json:"detector_id,omitempty"`
	// Storage of each column of pseudo-intensity values
	ElementIntensities []float32 `protobuf:"fixed32,2,rep,packed,name=element_intensities,json=elementIntensities,proto3" json:"element_intensities,omitempty"`
}

func (x *Experiment_Location_PseudoIntensityData) Reset() {
	*x = Experiment_Location_PseudoIntensityData{}
	if protoimpl.UnsafeEnabled {
		mi := &file_data_formats_experiment_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Experiment_Location_PseudoIntensityData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Experiment_Location_PseudoIntensityData) ProtoMessage() {}

func (x *Experiment_Location_PseudoIntensityData) ProtoReflect() protoreflect.Message {
	mi := &file_data_formats_experiment_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Experiment_Location_PseudoIntensityData.ProtoReflect.Descriptor instead.
func (*Experiment_Location_PseudoIntensityData) Descriptor() ([]byte, []int) {
	return file_data_formats_experiment_proto_rawDescGZIP(), []int{0, 3, 3}
}

func (x *Experiment_Location_PseudoIntensityData) GetDetectorId() string {
	if x != nil {
		return x.DetectorId
	}
	return ""
}

func (x *Experiment_Location_PseudoIntensityData) GetElementIntensities() []float32 {
	if x != nil {
		return x.ElementIntensities
	}
	return nil
}

type Experiment_Location_BeamLocation_Coordinate2D struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	I float32 `protobuf:"fixed32,1,opt,name=i,proto3" json:"i,omitempty"`
	J float32 `protobuf:"fixed32,2,opt,name=j,proto3" json:"j,omitempty"`
}

func (x *Experiment_Location_BeamLocation_Coordinate2D) Reset() {
	*x = Experiment_Location_BeamLocation_Coordinate2D{}
	if protoimpl.UnsafeEnabled {
		mi := &file_data_formats_experiment_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Experiment_Location_BeamLocation_Coordinate2D) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Experiment_Location_BeamLocation_Coordinate2D) ProtoMessage() {}

func (x *Experiment_Location_BeamLocation_Coordinate2D) ProtoReflect() protoreflect.Message {
	mi := &file_data_formats_experiment_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Experiment_Location_BeamLocation_Coordinate2D.ProtoReflect.Descriptor instead.
func (*Experiment_Location_BeamLocation_Coordinate2D) Descriptor() ([]byte, []int) {
	return file_data_formats_experiment_proto_rawDescGZIP(), []int{0, 3, 1, 0}
}

func (x *Experiment_Location_BeamLocation_Coordinate2D) GetI() float32 {
	if x != nil {
		return x.I
	}
	return 0
}

func (x *Experiment_Location_BeamLocation_Coordinate2D) GetJ() float32 {
	if x != nil {
		return x.J
	}
	return 0
}

var File_data_formats_experiment_proto protoreflect.FileDescriptor

var file_data_formats_experiment_proto_rawDesc = []byte{
	0x0a, 0x1d, 0x64, 0x61, 0x74, 0x61, 0x2d, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x73, 0x2f, 0x65,
	0x78, 0x70, 0x65, 0x72, 0x69, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22,
	0xb7, 0x18, 0x0a, 0x0a, 0x45, 0x78, 0x70, 0x65, 0x72, 0x69, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x1b,
	0x0a, 0x09, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x08, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x49, 0x64, 0x12, 0x19, 0x0a, 0x08, 0x64,
	0x72, 0x69, 0x76, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x05, 0x52, 0x07, 0x64,
	0x72, 0x69, 0x76, 0x65, 0x49, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x73, 0x69, 0x74, 0x65, 0x5f, 0x69,
	0x64, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x73, 0x69, 0x74, 0x65, 0x49, 0x64, 0x12,
	0x16, 0x0a, 0x06, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x06, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x69, 0x74, 0x65, 0x18,
	0x0e, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x73, 0x69, 0x74, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x74,
	0x69, 0x74, 0x6c, 0x65, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x69, 0x74, 0x6c,
	0x65, 0x12, 0x10, 0x0a, 0x03, 0x73, 0x6f, 0x6c, 0x18, 0x19, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,
	0x73, 0x6f, 0x6c, 0x12, 0x10, 0x0a, 0x03, 0x72, 0x74, 0x74, 0x18, 0x11, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x03, 0x72, 0x74, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x63, 0x6c, 0x6b, 0x18, 0x12, 0x20,
	0x01, 0x28, 0x05, 0x52, 0x04, 0x73, 0x63, 0x6c, 0x6b, 0x12, 0x2d, 0x0a, 0x13, 0x62, 0x75, 0x6c,
	0x6b, 0x5f, 0x73, 0x75, 0x6d, 0x5f, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x5f, 0x66, 0x69, 0x6c, 0x65,
	0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x62, 0x75, 0x6c, 0x6b, 0x53, 0x75, 0x6d, 0x51,
	0x75, 0x61, 0x6e, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x12, 0x27, 0x0a, 0x0f, 0x64, 0x65, 0x74, 0x65,
	0x63, 0x74, 0x6f, 0x72, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x0a, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x0e, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x12, 0x21, 0x0a, 0x0c, 0x62, 0x75, 0x6c, 0x6b, 0x5f, 0x73, 0x70, 0x65, 0x63, 0x74, 0x72,
	0x61, 0x18, 0x13, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0b, 0x62, 0x75, 0x6c, 0x6b, 0x53, 0x70, 0x65,
	0x63, 0x74, 0x72, 0x61, 0x12, 0x23, 0x0a, 0x0d, 0x64, 0x77, 0x65, 0x6c, 0x6c, 0x5f, 0x73, 0x70,
	0x65, 0x63, 0x74, 0x72, 0x61, 0x18, 0x14, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0c, 0x64, 0x77, 0x65,
	0x6c, 0x6c, 0x53, 0x70, 0x65, 0x63, 0x74, 0x72, 0x61, 0x12, 0x1f, 0x0a, 0x0b, 0x6d, 0x61, 0x78,
	0x5f, 0x73, 0x70, 0x65, 0x63, 0x74, 0x72, 0x61, 0x18, 0x15, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a,
	0x6d, 0x61, 0x78, 0x53, 0x70, 0x65, 0x63, 0x74, 0x72, 0x61, 0x12, 0x25, 0x0a, 0x0e, 0x6e, 0x6f,
	0x72, 0x6d, 0x61, 0x6c, 0x5f, 0x73, 0x70, 0x65, 0x63, 0x74, 0x72, 0x61, 0x18, 0x16, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x0d, 0x6e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x53, 0x70, 0x65, 0x63, 0x74, 0x72,
	0x61, 0x12, 0x2d, 0x0a, 0x12, 0x70, 0x73, 0x65, 0x75, 0x64, 0x6f, 0x5f, 0x69, 0x6e, 0x74, 0x65,
	0x6e, 0x73, 0x69, 0x74, 0x69, 0x65, 0x73, 0x18, 0x17, 0x20, 0x01, 0x28, 0x05, 0x52, 0x11, 0x70,
	0x73, 0x65, 0x75, 0x64, 0x6f, 0x49, 0x6e, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x65, 0x73,
	0x12, 0x2c, 0x0a, 0x12, 0x6d, 0x61, 0x69, 0x6e, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74,
	0x5f, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x6d, 0x61,
	0x69, 0x6e, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x39,
	0x0a, 0x0c, 0x73, 0x63, 0x61, 0x6e, 0x5f, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x18, 0x1b,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x45, 0x78, 0x70, 0x65, 0x72, 0x69, 0x6d, 0x65, 0x6e,
	0x74, 0x2e, 0x53, 0x63, 0x61, 0x6e, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x0b, 0x73, 0x63,
	0x61, 0x6e, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x12, 0x5c, 0x0a, 0x16, 0x61, 0x6c, 0x69,
	0x67, 0x6e, 0x65, 0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x5f, 0x69, 0x6d, 0x61,
	0x67, 0x65, 0x73, 0x18, 0x18, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x45, 0x78, 0x70, 0x65,
	0x72, 0x69, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x49, 0x6d,
	0x61, 0x67, 0x65, 0x43, 0x6f, 0x6f, 0x72, 0x64, 0x69, 0x6e, 0x61, 0x74, 0x65, 0x49, 0x6e, 0x66,
	0x6f, 0x52, 0x14, 0x61, 0x6c, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78,
	0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x73, 0x12, 0x38, 0x0a, 0x18, 0x75, 0x6e, 0x61, 0x6c, 0x69,
	0x67, 0x6e, 0x65, 0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x5f, 0x69, 0x6d, 0x61,
	0x67, 0x65, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x09, 0x52, 0x16, 0x75, 0x6e, 0x61, 0x6c, 0x69,
	0x67, 0x6e, 0x65, 0x64, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65,
	0x73, 0x12, 0x68, 0x0a, 0x1e, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x5f, 0x61, 0x6c, 0x69,
	0x67, 0x6e, 0x65, 0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x5f, 0x69, 0x6d, 0x61,
	0x67, 0x65, 0x73, 0x18, 0x1a, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x45, 0x78, 0x70, 0x65,
	0x72, 0x69, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x43, 0x6f,
	0x6e, 0x74, 0x65, 0x78, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x1b,
	0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x41, 0x6c, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x43, 0x6f,
	0x6e, 0x74, 0x65, 0x78, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x6d,
	0x65, 0x74, 0x61, 0x5f, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09,
	0x52, 0x0a, 0x6d, 0x65, 0x74, 0x61, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x12, 0x37, 0x0a, 0x0a,
	0x6d, 0x65, 0x74, 0x61, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0e,
	0x32, 0x18, 0x2e, 0x45, 0x78, 0x70, 0x65, 0x72, 0x69, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4d, 0x65,
	0x74, 0x61, 0x44, 0x61, 0x74, 0x61, 0x54, 0x79, 0x70, 0x65, 0x52, 0x09, 0x6d, 0x65, 0x74, 0x61,
	0x54, 0x79, 0x70, 0x65, 0x73, 0x12, 0x32, 0x0a, 0x09, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x45, 0x78, 0x70, 0x65, 0x72,
	0x69, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x09,
	0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x58, 0x0a, 0x17, 0x70, 0x73, 0x65,
	0x75, 0x64, 0x6f, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x74, 0x79, 0x5f, 0x72, 0x61,
	0x6e, 0x67, 0x65, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x45, 0x78, 0x70,
	0x65, 0x72, 0x69, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x73, 0x65, 0x75, 0x64, 0x6f, 0x49, 0x6e,
	0x74, 0x65, 0x6e, 0x73, 0x69, 0x74, 0x79, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x15, 0x70, 0x73,
	0x65, 0x75, 0x64, 0x6f, 0x49, 0x6e, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x74, 0x79, 0x52, 0x61, 0x6e,
	0x67, 0x65, 0x73, 0x1a, 0xec, 0x02, 0x0a, 0x0a, 0x53, 0x63, 0x61, 0x6e, 0x53, 0x6f, 0x75, 0x72,
	0x63, 0x65, 0x12, 0x1e, 0x0a, 0x0a, 0x69, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x6d, 0x65, 0x6e, 0x74,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x69, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x6d, 0x65,
	0x6e, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x5f, 0x69, 0x64, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x49, 0x64, 0x12,
	0x19, 0x0a, 0x08, 0x64, 0x72, 0x69, 0x76, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x07, 0x64, 0x72, 0x69, 0x76, 0x65, 0x49, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x73, 0x69,
	0x74, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x73, 0x69, 0x74,
	0x65, 0x49, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x06, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x73,
	0x69, 0x74, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x73, 0x69, 0x74, 0x65, 0x12,
	0x14, 0x0a, 0x05, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05,
	0x74, 0x69, 0x74, 0x6c, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x73, 0x6f, 0x6c, 0x18, 0x08, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x03, 0x73, 0x6f, 0x6c, 0x12, 0x10, 0x0a, 0x03, 0x72, 0x74, 0x74, 0x18, 0x09,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x72, 0x74, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x63, 0x6c,
	0x6b, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x73, 0x63, 0x6c, 0x6b, 0x12, 0x2d, 0x0a,
	0x13, 0x62, 0x75, 0x6c, 0x6b, 0x5f, 0x73, 0x75, 0x6d, 0x5f, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x5f,
	0x66, 0x69, 0x6c, 0x65, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x62, 0x75, 0x6c, 0x6b,
	0x53, 0x75, 0x6d, 0x51, 0x75, 0x61, 0x6e, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x12, 0x27, 0x0a, 0x0f,
	0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18,
	0x0c, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1b, 0x0a, 0x09, 0x69, 0x64, 0x5f, 0x6f, 0x66, 0x66, 0x73,
	0x65, 0x74, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x69, 0x64, 0x4f, 0x66, 0x66, 0x73,
	0x65, 0x74, 0x1a, 0x96, 0x01, 0x0a, 0x1a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x49, 0x6d,
	0x61, 0x67, 0x65, 0x43, 0x6f, 0x6f, 0x72, 0x64, 0x69, 0x6e, 0x61, 0x74, 0x65, 0x49, 0x6e, 0x66,
	0x6f, 0x12, 0x14, 0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x70, 0x6d, 0x63, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x70, 0x6d, 0x63, 0x12, 0x2f, 0x0a, 0x13, 0x74, 0x72, 0x61,
	0x70, 0x65, 0x7a, 0x6f, 0x69, 0x64, 0x5f, 0x63, 0x6f, 0x72, 0x72, 0x65, 0x63, 0x74, 0x65, 0x64,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x12, 0x74, 0x72, 0x61, 0x70, 0x65, 0x7a, 0x6f, 0x69,
	0x64, 0x43, 0x6f, 0x72, 0x72, 0x65, 0x63, 0x74, 0x65, 0x64, 0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x63,
	0x61, 0x6e, 0x5f, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52,
	0x0a, 0x73, 0x63, 0x61, 0x6e, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x1a, 0xbc, 0x01, 0x0a, 0x17,
	0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x49, 0x6d,
	0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x14, 0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x23, 0x0a,
	0x0d, 0x61, 0x6c, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x0c, 0x61, 0x6c, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x49, 0x6e, 0x64,
	0x65, 0x78, 0x12, 0x19, 0x0a, 0x08, 0x78, 0x5f, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x02, 0x52, 0x07, 0x78, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x12, 0x19, 0x0a,
	0x08, 0x79, 0x5f, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x02, 0x52,
	0x07, 0x79, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x78, 0x5f, 0x73, 0x63,
	0x61, 0x6c, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x02, 0x52, 0x06, 0x78, 0x53, 0x63, 0x61, 0x6c,
	0x65, 0x12, 0x17, 0x0a, 0x07, 0x79, 0x5f, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x02, 0x52, 0x06, 0x79, 0x53, 0x63, 0x61, 0x6c, 0x65, 0x1a, 0xfb, 0x08, 0x0a, 0x08, 0x4c,
	0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x63, 0x61, 0x6e, 0x5f,
	0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a, 0x73, 0x63,
	0x61, 0x6e, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x35, 0x0a, 0x04, 0x6d, 0x65, 0x74, 0x61,
	0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x45, 0x78, 0x70, 0x65, 0x72, 0x69, 0x6d,
	0x65, 0x6e, 0x74, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x4d, 0x65, 0x74,
	0x61, 0x44, 0x61, 0x74, 0x61, 0x49, 0x74, 0x65, 0x6d, 0x52, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x12,
	0x35, 0x0a, 0x04, 0x62, 0x65, 0x61, 0x6d, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e,
	0x45, 0x78, 0x70, 0x65, 0x72, 0x69, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x2e, 0x42, 0x65, 0x61, 0x6d, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x52, 0x04, 0x62, 0x65, 0x61, 0x6d, 0x12, 0x5b, 0x0a, 0x14, 0x73, 0x70, 0x65, 0x63, 0x74, 0x72,
	0x75, 0x6d, 0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x0e, 0x32, 0x28, 0x2e, 0x45, 0x78, 0x70, 0x65, 0x72, 0x69, 0x6d, 0x65, 0x6e,
	0x74, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x53, 0x70, 0x65, 0x63, 0x74,
	0x72, 0x75, 0x6d, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x13,
	0x73, 0x70, 0x65, 0x63, 0x74, 0x72, 0x75, 0x6d, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73,
	0x69, 0x6f, 0x6e, 0x12, 0x43, 0x0a, 0x09, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73,
	0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x45, 0x78, 0x70, 0x65, 0x72, 0x69, 0x6d,
	0x65, 0x6e, 0x74, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x44, 0x65, 0x74,
	0x65, 0x63, 0x74, 0x6f, 0x72, 0x53, 0x70, 0x65, 0x63, 0x74, 0x72, 0x75, 0x6d, 0x52, 0x09, 0x64,
	0x65, 0x74, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6e, 0x74,
	0x65, 0x78, 0x74, 0x5f, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x57, 0x0a,
	0x12, 0x70, 0x73, 0x65, 0x75, 0x64, 0x6f, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x74,
	0x69, 0x65, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x45, 0x78, 0x70, 0x65,
	0x72, 0x69, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
	0x50, 0x73, 0x65, 0x75, 0x64, 0x6f, 0x49, 0x6e, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x74, 0x79, 0x44,
	0x61, 0x74, 0x61, 0x52, 0x11, 0x70, 0x73, 0x65, 0x75, 0x64, 0x6f, 0x49, 0x6e, 0x74, 0x65, 0x6e,
	0x73, 0x69, 0x74, 0x69, 0x65, 0x73, 0x1a, 0x73, 0x0a, 0x0c, 0x4d, 0x65, 0x74, 0x61, 0x44, 0x61,
	0x74, 0x61, 0x49, 0x74, 0x65, 0x6d, 0x12, 0x1b, 0x0a, 0x09, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f,
	0x69, 0x64, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x6c, 0x61, 0x62, 0x65, 0x6c,
	0x49, 0x64, 0x78, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x02, 0x52, 0x06, 0x66, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x69,
	0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x69, 0x76, 0x61,
	0x6c, 0x75, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x1a, 0x90, 0x02, 0x0a, 0x0c,
	0x42, 0x65, 0x61, 0x6d, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x0c, 0x0a, 0x01,
	0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x02, 0x52, 0x01, 0x78, 0x12, 0x0c, 0x0a, 0x01, 0x79, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x02, 0x52, 0x01, 0x79, 0x12, 0x0c, 0x0a, 0x01, 0x7a, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x02, 0x52, 0x01, 0x7a, 0x12, 0x1b, 0x0a, 0x09, 0x67, 0x65, 0x6f, 0x6d, 0x5f, 0x63,
	0x6f, 0x72, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x02, 0x52, 0x08, 0x67, 0x65, 0x6f, 0x6d, 0x43,
	0x6f, 0x72, 0x72, 0x12, 0x17, 0x0a, 0x07, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x02, 0x52, 0x06, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x49, 0x12, 0x17, 0x0a, 0x07,
	0x69, 0x6d, 0x61, 0x67, 0x65, 0x5f, 0x6a, 0x18, 0x05, 0x20, 0x01, 0x28, 0x02, 0x52, 0x06, 0x69,
	0x6d, 0x61, 0x67, 0x65, 0x4a, 0x12, 0x5b, 0x0a, 0x11, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74,
	0x5f, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x2e, 0x2e, 0x45, 0x78, 0x70, 0x65, 0x72, 0x69, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4c, 0x6f,
	0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x42, 0x65, 0x61, 0x6d, 0x4c, 0x6f, 0x63, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x2e, 0x43, 0x6f, 0x6f, 0x72, 0x64, 0x69, 0x6e, 0x61, 0x74, 0x65, 0x32, 0x44,
	0x52, 0x10, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x1a, 0x2a, 0x0a, 0x0c, 0x43, 0x6f, 0x6f, 0x72, 0x64, 0x69, 0x6e, 0x61, 0x74, 0x65,
	0x32, 0x44, 0x12, 0x0c, 0x0a, 0x01, 0x69, 0x18, 0x01, 0x20, 0x01, 0x28, 0x02, 0x52, 0x01, 0x69,
	0x12, 0x0c, 0x0a, 0x01, 0x6a, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x52, 0x01, 0x6a, 0x1a, 0x87,
	0x01, 0x0a, 0x10, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x53, 0x70, 0x65, 0x63, 0x74,
	0x72, 0x75, 0x6d, 0x12, 0x35, 0x0a, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x18, 0x01, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x21, 0x2e, 0x45, 0x78, 0x70, 0x65, 0x72, 0x69, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4c,
	0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x4d, 0x65, 0x74, 0x61, 0x44, 0x61, 0x74, 0x61,
	0x49, 0x74, 0x65, 0x6d, 0x52, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x12, 0x1a, 0x0a, 0x08, 0x73, 0x70,
	0x65, 0x63, 0x74, 0x72, 0x75, 0x6d, 0x18, 0x02, 0x20, 0x03, 0x28, 0x05, 0x52, 0x08, 0x73, 0x70,
	0x65, 0x63, 0x74, 0x72, 0x75, 0x6d, 0x12, 0x20, 0x0a, 0x0b, 0x73, 0x70, 0x65, 0x63, 0x74, 0x72,
	0x75, 0x6d, 0x4d, 0x61, 0x78, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0b, 0x73, 0x70, 0x65,
	0x63, 0x74, 0x72, 0x75, 0x6d, 0x4d, 0x61, 0x78, 0x1a, 0x67, 0x0a, 0x13, 0x50, 0x73, 0x65, 0x75,
	0x64, 0x6f, 0x49, 0x6e, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x74, 0x79, 0x44, 0x61, 0x74, 0x61, 0x12,
	0x1f, 0x0a, 0x0b, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x49, 0x64,
	0x12, 0x2f, 0x0a, 0x13, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x6e, 0x74, 0x65,
	0x6e, 0x73, 0x69, 0x74, 0x69, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x02, 0x52, 0x12, 0x65,
	0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x6e, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x65,
	0x73, 0x22, 0x35, 0x0a, 0x13, 0x53, 0x70, 0x65, 0x63, 0x74, 0x72, 0x75, 0x6d, 0x43, 0x6f, 0x6d,
	0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x07, 0x0a, 0x03, 0x52, 0x41, 0x57, 0x10,
	0x00, 0x12, 0x0c, 0x0a, 0x08, 0x5a, 0x45, 0x52, 0x4f, 0x5f, 0x52, 0x55, 0x4e, 0x10, 0x01, 0x12,
	0x07, 0x0a, 0x03, 0x52, 0x4c, 0x45, 0x10, 0x02, 0x1a, 0x70, 0x0a, 0x14, 0x50, 0x73, 0x65, 0x75,
	0x64, 0x6f, 0x49, 0x6e, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x74, 0x79, 0x52, 0x61, 0x6e, 0x67, 0x65,
	0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
	0x6e, 0x61, 0x6d, 0x65, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f,
	0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0c, 0x63, 0x68, 0x61,
	0x6e, 0x6e, 0x65, 0x6c, 0x53, 0x74, 0x61, 0x72, 0x74, 0x12, 0x1f, 0x0a, 0x0b, 0x63, 0x68, 0x61,
	0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x65, 0x6e, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a,
	0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x45, 0x6e, 0x64, 0x22, 0x37, 0x0a, 0x0c, 0x4d, 0x65,
	0x74, 0x61, 0x44, 0x61, 0x74, 0x61, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0c, 0x0a, 0x08, 0x4d, 0x54,
	0x5f, 0x46, 0x4c, 0x4f, 0x41, 0x54, 0x10, 0x00, 0x12, 0x0a, 0x0a, 0x06, 0x4d, 0x54, 0x5f, 0x49,
	0x4e, 0x54, 0x10, 0x01, 0x12, 0x0d, 0x0a, 0x09, 0x4d, 0x54, 0x5f, 0x53, 0x54, 0x52, 0x49, 0x4e,
	0x47, 0x10, 0x02, 0x4a, 0x04, 0x08, 0x10, 0x10, 0x11, 0x42, 0x0a, 0x5a, 0x08, 0x2e, 0x3b, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x73, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_data_formats_experiment_proto_rawDescOnce sync.Once
	file_data_formats_experiment_proto_rawDescData = file_data_formats_experiment_proto_rawDesc
)

func file_data_formats_experiment_proto_rawDescGZIP() []byte {
	file_data_formats_experiment_proto_rawDescOnce.Do(func() {
		file_data_formats_experiment_proto_rawDescData = protoimpl.X.CompressGZIP(file_data_formats_experiment_proto_rawDescData)
	})
	return file_data_formats_experiment_proto_rawDescData
}

var file_data_formats_experiment_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_data_formats_experiment_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
var file_data_formats_experiment_proto_goTypes = []interface{}{
	(Experiment_MetaDataType)(0),                          // 0: Experiment.MetaDataType
	(Experiment_Location_SpectrumCompression)(0),          // 1: Experiment.Location.SpectrumCompression
	(*Experiment)(nil),                                    // 2: Experiment
	(*Experiment_ScanSource)(nil),                         // 3: Experiment.ScanSource
	(*Experiment_ContextImageCoordinateInfo)(nil),         // 4: Experiment.ContextImageCoordinateInfo
	(*Experiment_MatchedContextImageInfo)(nil),            // 5: Experiment.MatchedContextImageInfo
	(*Experiment_Location)(nil),                           // 6: Experiment.Location
	(*Experiment_PseudoIntensityRange)(nil),               // 7: Experiment.PseudoIntensityRange
	(*Experiment_Location_MetaDataItem)(nil),              // 8: Experiment.Location.MetaDataItem
	(*Experiment_Location_BeamLocation)(nil),              // 9: Experiment.Location.BeamLocation
	(*Experiment_Location_DetectorSpectrum)(nil),          // 10: Experiment.Location.DetectorSpectrum
	(*Experiment_Location_PseudoIntensityData)(nil),       // 11: Experiment.Location.PseudoIntensityData
	(*Experiment_Location_BeamLocation_Coordinate2D)(nil), // 12: Experiment.Location.BeamLocation.Coordinate2D
}
var file_data_formats_experiment_proto_depIdxs = []int32{
	3,  // 0: Experiment.scan_sources:type_name -> Experiment.ScanSource
	4,  // 1: Experiment.aligned_context_images:type_name -> Experiment.ContextImageCoordinateInfo
	5,  // 2: Experiment.matched_aligned_context_images:type_name -> Experiment.MatchedContextImageInfo
	0,  // 3: Experiment.meta_types:type_name -> Experiment.MetaDataType
	6,  // 4: Experiment.locations:type_name -> Experiment.Location
	7,  // 5: Experiment.pseudo_intensity_ranges:type_name -> Experiment.PseudoIntensityRange
	8,  // 6: Experiment.Location.meta:type_name -> Experiment.Location.MetaDataItem
	9,  // 7: Experiment.Location.beam:type_name -> Experiment.Location.BeamLocation
	1,  // 8: Experiment.Location.spectrum_compression:type_name -> Experiment.Location.SpectrumCompression
	10, // 9: Experiment.Location.detectors:type_name -> Experiment.Location.DetectorSpectrum
	11, // 10: Experiment.Location.pseudo_intensities:type_name -> Experiment.Location.PseudoIntensityData
	12, // 11: Experiment.Location.BeamLocation.context_locations:type_name -> Experiment.Location.BeamLocation.Coordinate2D
	8,  // 12: Experiment.Location.DetectorSpectrum.meta:type_name -> Experiment.Location.MetaDataItem
	13, // [13:13] is the sub-list for method output_type
	13, // [13:13] is the sub-list for method input_type
	13, // [13:13] is the sub-list for extension type_name
	13, // [13:13] is the sub-list for extension extendee
	0,  // [0:13] is the sub-list for field type_name
}

func init() { file_data_formats_experiment_proto_init() }
func file_data_formats_experiment_proto_init() {
	if File_data_formats_experiment_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_data_formats_experiment_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Experiment); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_data_formats_experiment_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Experiment_ScanSource); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_data_formats_experiment_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Experiment_ContextImageCoordinateInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_data_formats_experiment_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Experiment_MatchedContextImageInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_data_formats_experiment_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Experiment_Location); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_data_formats_experiment_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Experiment_PseudoIntensityRange); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_data_formats_experiment_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Experiment_Location_MetaDataItem); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_data_formats_experiment_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Experiment_Location_BeamLocation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_data_formats_experiment_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Experiment_Location_DetectorSpectrum); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_data_formats_experiment_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Experiment_Location_PseudoIntensityData); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_data_formats_experiment_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Experiment_Location_BeamLocation_Coordinate2D); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_data_formats_experiment_proto_rawDesc,
			NumEnums:      2,
			NumMessages:   11,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_data_formats_experiment_proto_goTypes,
		DependencyIndexes: file_data_formats_experiment_proto_depIdxs,
		EnumInfos:         file_data_formats_experiment_proto_enumTypes,
		MessageInfos:      file_data_formats_experiment_proto_msgTypes,
	}.Build()
	File_data_formats_experiment_proto = out.File
	file_data_formats_experiment_proto_rawDesc = nil
	file_data_formats_experiment_proto_goTypes = nil
	file_data_formats_experiment_proto_depIdxs = nil
}
