// Copyright (c) 2018-2022 California Institute of Technology (“Caltech”). U.S.
// Government sponsorship acknowledged.
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
// * Neither the name of Caltech nor its operating division, the Jet Propulsion
//   Laboratory, nor the names of its contributors may be used to endorse or
//   promote products derived from this software without specific prior written
//   permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

package filepaths

import (
	"path"
	"strings"

	"github.com/pixlise/core/core/fileaccess"
	"github.com/pixlise/core/core/pixlUser"
)

// This package contains all file paths that the PIXLISE API should ever need to access. All been centralised
// so we have one place to change it all. Several helper functions are provided to make certain paths given
// a user ID or dataset ID, etc.

// Our data resides across several buckets:

////////////////////////////////////////////////////////////////////////////////////
// Data Bucket
////////////////////////////////////////////////////////////////////////////////////
// This contains most of our data, including dataset files, user-created config/object files, quantifications, PIXLISE/PIQUANT/API config files
// Contains:

// - Datasets/
const RootDatasets = "Datasets"

//       <dataset-id>/
//           dataset.bin - The dataset file containing all spectra, housekeeping, beam locations, etc. Created by data-converter
const DatasetFileName = "dataset.bin"

//           diffraction-db.bin - Diffraction peak database, generated by diffraction-detector when dataset is imported
const DiffractionDBFileName = "diffraction-db.bin"

//           summary.json - Contains metadata for the dataset, easily downloadable/browsable. dataset-tile-updater pulls these in to form the datasets.json file
const DatasetSummaryFileName = "summary.json"

//           Context image files (.png or .jpg)
//           RGBU multi-spectral files (.tif)
func GetDatasetFilePath(datasetID string, fileName string) string {
	return path.Join(RootDatasets, datasetID, fileName)
}

// - DetectorConfig/
const RootDetectorConfig = "DetectorConfig"

//       <config-name>/ - Name shown on UI, eg PIXL or Breadboard
//           pixlise-config.json - UI config values for this detector, eg detector energy range, window material, etc
//           PiquantConfigs/
const PiquantConfigSubDir = "PiquantConfigs" // - NOTE: Quant creation doesn't use GetDetectorConfigPath, maybe DetectorConfig is hard-coded into docker container!

//               <version>/ - eg v1, v2, v3
//                   config.json - The PIQUANT config file, used by quant "runner", in docker container. References other files
//                   <other files>.msa or .csv - These are referenced by config.json and passed to PIQUANT exe as parameters
func GetDetectorConfigFilePath(configName string) string {
	return path.Join(RootDetectorConfig, configName, "pixlise-config.json")
}
func GetDetectorConfigPath(configName string, version string, fileName string) string {
	if len(version) > 0 {
		if len(fileName) > 0 {
			return path.Join(RootDetectorConfig, configName, PiquantConfigSubDir, version, fileName)
		} else {
			return path.Join(RootDetectorConfig, configName, PiquantConfigSubDir, version)
		}
	}
	return path.Join(RootDetectorConfig, configName, PiquantConfigSubDir)
}

const PiquantConfigFileName = "config.json"

// - PixliseConfig/
const RootPixliseConfigPath = "PixliseConfig"

//       auth0.pem - Certificate needed by Auth0 to verify a user request is valid
const Auth0PemFileName = "auth0.pem"

//       config.json - API config file it downloads on startup, contains buckets, keys, kubernetes settings, etc
const APIConfigFileName = "config.json"

//       datasets.json - Dataset list (tiles). Regenerated every time Datasets/ changes by lambda function: dataset-tile-updater
func GetDatasetListPath() string {
	return GetConfigFilePath("datasets.json")
}

//       piquant-version.json - Config contains the docker container to use for PIQUANT. Separate from config.json because users can configure this in UI
const PiquantVersionFileName = "piquant-version.json"

func GetConfigFilePath(fileName string) string {
	return path.Join(RootPixliseConfigPath, fileName)
}

// - UserContent/
const RootUserContent = "UserContent"

//       <user-id>/
//           ElementSets.json - User created element sets
const elementSetFile = "ElementSets.json"

//           DataExpressions.json - User created expressions
const expressionFile = "DataExpressions.json"

//           RGBMixes.json - User created RGB mixes
const rgbMixFile = "RGBMixes.json"

//           <dataset-id>/
//               ROI.json - User created ROIs
const roiFile = "ROI.json"

//               multi-quant-z-stack.json - The current z-stack on multi-quant panel
const MultiQuantZStackFile = "multi-quant-z-stack.json"

//               SpectrumAnnotation.json
const annotationFile = "SpectrumAnnotation.json"

//               Quantifications/
const quantificationSubPath = "Quantifications"

//                   <quant-id>.bin - The combined.csv file converted to protobuf binary format by quant-converter
//                   <quant-id>.csv - Copied from Job Bucket/JobData/<job-id>/output/combined.csv
//                   <quant-id>-logs/ - Copied from Job Bucket/JobData/<job-id>/piquant-logs/
//                   summary-<quant-id>.json - Quant summary file
func GetUserQuantPath(userID string, datasetID string, fileName string) string {
	if len(fileName) > 0 {
		return path.Join(RootUserContent, userID, datasetID, quantificationSubPath, fileName)
	}
	return path.Join(RootUserContent, userID, datasetID, quantificationSubPath)
}

//               ViewState/
const viewStatePath = "ViewState"

//                   quantification.json - The quantification loaded on UI top toolbar
//                   roi.json - Colours assigned to ROIs on the UI
//                   selection.json - The users current selection of PMCs and/or pixels on UI
//                   analysisLayout.json - What widgets go where, top row/bottom row
//                   <panel-type>-<location>.json - States of various UI panels and where they are
//                   See: GetViewStatePath()
//                   Workspaces/
const viewStateSavedSubpath = "Workspaces"

//                       <workspace-name>.json - View state files (like up one directory) flattened to a file and given a workspace name. Note the file also contains the workspace name, the file name may have been modified for saving, eg removal of /
//                       See: GetWorkspacePath()
//                   WorkspaceCollections/
const viewStateCollectionsSubpath = "WorkspaceCollections"

//                       <collection-name>.json
//                       See: GetCollectionPath()
//
// The above paths can be created with the above file names...
func GetUserContentPath(userID string, fileName string) string {
	return path.Join(RootUserContent, userID, fileName)
}
func GetUserContentDatasetPath(userID string, datasetID string, fileName string) string {
	return path.Join(RootUserContent, userID, datasetID, fileName)
}

//       shared/ - Same as for a <user-id> but contains all files that were shared. These are copies of the user ones, along with "
//                 NOTE: Special case is diffraction/roughness user files, these only exist in shared directory
const DiffractionPeakManualFileName = "manual-diffraction-peaks.json"
const DiffractionPeakStatusFileName = "diffraction-peak-statuses.json"

func GetSharedContentDatasetPath(datasetID string, fileName string) string {
	return path.Join(RootUserContent, pixlUser.ShareUserID, datasetID, fileName)
}
func GetSharedQuantPath(datasetID string, fileName string) string {
	return GetUserQuantPath(pixlUser.ShareUserID, datasetID, fileName)
}

//       notifications/
//           <user-id>.json - Notification settings, dismissed hints, user email, data collection version agreed to

////////////////////////////////////////////////////////////////////////////////////
// Job Bucket
////////////////////////////////////////////////////////////////////////////////////
// This contains temporary files generated when running a long-running job (eg PIQUANT).
// Contains parameters to the job, status files, log files from the job, intermediate calculation files
// These are in separate directories to aid listing, so instead of returning 100s of files per job
// you may only want a list of job statuses, where you'd only get 1 file per job
// Contains:
// - JobData/
const RootJobData = "JobData"

//       <dataset-id>/
//           <job-id>/
//               node*.pmcs - PMC list for a given node running the job
//               params.json - Job parameters as specified when created
//               output/
//                   node*.pmcs_result.csv - CSV generated by a single node, intermediate outpu
//                   combined.csv - The final output generated by combining all the node*.pmcs_result.csv files
//               piquant-logs/
const PiquantLogSubdir = "piquant-logs"

//                   node*.pmcs_piquant.log - PIQUANT log file for a given node
//                   node*.pmcs_stdout.log - stdout for running PIQUANT on a given node
func GetJobDataPath(datasetID string, jobID string, fileName string) string {
	if len(jobID) > 0 {
		if len(fileName) > 0 {
			return path.Join(RootJobData, datasetID, jobID, fileName)
		}
		return path.Join(RootJobData, datasetID, jobID)
	}
	return path.Join(RootJobData, datasetID)
}

// - JobStatus/
const RootJobStatus = "JobStatus"

//       <dataset-id>/<job-id>-status.json
const JobStatusSuffix = "-status.json"

func GetJobStatusPath(datasetID string, jobID string) string {
	if len(jobID) <= 0 {
		return path.Join(RootJobStatus, datasetID)
	}
	return path.Join(RootJobStatus, datasetID, jobID+JobStatusSuffix)
}

// - JobSummaries/
const RootJobSummaries = "JobSummaries"

//       <dataset-id>-jobs.json - Summary files describing all jobs for a dataset
const JobSummarySuffix = "-jobs.json"

func GetJobSummaryPath(datasetID string) string {
	return path.Join(RootJobSummaries, datasetID+JobSummarySuffix)
}

////////////////////////////////////////////////////////////////////////////////////
// Artifacts Manual Upload Data Source Bucket
////////////////////////////////////////////////////////////////////////////////////
// - dataset-addons/
const datasetCustomRoot = "dataset-addons"

//       <dataset-id>/
//           custom-meta.json - Custom metadata for this dataset, usually to set dataset title, but can also contain matched image scale/bias or other fields
const DatasetCustomMetaFileName = "custom-meta.json"

//           UNALINED/
//               image, *.png or *.jpg
//           MATCHED/
//               image, *.png, *.jpg or *.tif (if TIF it's considered an RGBU multi-spectral image)
//           RGBU/
//               images, *.tif - NOTE: Went unused, these are now all stored as MATCHED images
func GetCustomMetaPath(datasetID string) string {
	return path.Join(datasetCustomRoot, datasetID, DatasetCustomMetaFileName)
}
func GetCustomImagePath(datasetID string, imgType string, fileName string) string {
	// NOTE: We assume imgType is valid!
	s3Path := path.Join(datasetCustomRoot, datasetID, strings.ToUpper(imgType))
	if len(fileName) > 0 {
		s3Path = path.Join(s3Path, fileName)
	}
	return s3Path
}

////////////////////////////////////////////////////////////////////////////////////
// Artifacts Built Bucket - where we go to download built PIQUANT, etc
////////////////////////////////////////////////////////////////////////////////////
// - piquant/
//      piquant-linux-*.zip - Built PIQUANT executables (zipped)
const PiquantDownloadPath = "piquant"

////////////////////////////////////////////////////////////////////////////////////
// Some specific helper functions for better searchability/grouping
////////////////////////////////////////////////////////////////////////////////////

func GetElementSetPath(userID string) string {
	return GetUserContentPath(userID, elementSetFile)
}

func GetExpressionPath(userID string) string {
	return GetUserContentPath(userID, expressionFile)
}

func GetRGBMixPath(userID string) string {
	return GetUserContentPath(userID, rgbMixFile)
}

func GetROIPath(userID string, datasetID string) string {
	return GetUserContentDatasetPath(userID, datasetID, roiFile)
}

func GetMultiQuantZStackPath(userID string, datasetID string) string {
	return GetUserContentDatasetPath(userID, datasetID, MultiQuantZStackFile)
}

func GetAnnotationsPath(userID string, datasetID string) string {
	return GetUserContentDatasetPath(userID, datasetID, annotationFile)
}

func GetViewStatePath(userID string, datasetID string, fileName string) string {
	if len(fileName) <= 0 {
		// Just return the root of this
		return path.Join(RootUserContent, userID, datasetID, viewStatePath)
	}
	return path.Join(RootUserContent, userID, datasetID, viewStatePath, fileName+".json")
}

func GetWorkspacePath(userID string, datasetID string, id string) string {
	if len(id) <= 0 {
		// Just return the root of this
		return path.Join(RootUserContent, userID, datasetID, viewStatePath, viewStateSavedSubpath)
	}
	// ensure it's a valid file name
	id = fileaccess.MakeValidObjectName(id)
	return path.Join(RootUserContent, userID, datasetID, viewStatePath, viewStateSavedSubpath, id+".json")
}

func GetCollectionPath(userID string, datasetID string, id string) string {
	if len(id) <= 0 {
		// Just return the root of this
		return path.Join(RootUserContent, userID, datasetID, viewStatePath, viewStateCollectionsSubpath)
	}
	// ensure it's a valid file name
	id = fileaccess.MakeValidObjectName(id)
	return path.Join(RootUserContent, userID, datasetID, viewStatePath, viewStateCollectionsSubpath, id+".json")
}

////////////////////////////////////////////////////////////////////////////////////
// Helpers for forming certain file names
////////////////////////////////////////////////////////////////////////////////////

// QuantSummaryFilePrefix - summary files are summary-<jobid>.json
const QuantSummaryFilePrefix = "summary-"

// MakeQuantSummaryFileName - Given a quant ID, generates the file name: summary-<jobid>.json (use this for searchability/consistency)
func MakeQuantSummaryFileName(quantID string) string {
	return QuantSummaryFilePrefix + quantID + ".json"
}

// QuantFileSuffix - quant files are <jobid>.bin
const QuantFileSuffix = ".bin"

func MakeQuantDataFileName(quantID string) string {
	return quantID + QuantFileSuffix
}

// CSVFileSuffix - CSV files are <jobid>.csv
const CSVFileSuffix = ".csv"

func MakeQuantCSVFileName(quantID string) string {
	return quantID + CSVFileSuffix
}

// QuantLogsSubDirSuffix - this goes after job ID to form a directory name that stores the quant logs
const QuantLogsSubDirSuffix = "-logs"

func MakeQuantLogDirName(quantID string) string {
	return quantID + QuantLogsSubDirSuffix
}
